package dnsutils

import (
	"errors"
	"fmt"
	"testing"

	"github.com/dmachard/go-dnscollector/pkgconfig"
)

func TestDecodePayload_QueryHappy(t *testing.T) {
	payload := []byte{
		// header
		0x9e, 0x84, 0x01, 0x20, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01,
		// query section
		// name
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Additional records: EDNS OPT with no data, DO = 0, Z=0
		0x00, 0x00, 0x29, 0x10, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Errorf("Unexpected error while decoding payload: %v", err)
	}
	if dm.DNS.MalformedPacket != false {
		t.Errorf("did not expect packet to be malformed")
	}

	if dm.DNS.ID != 0x9e84 ||
		dm.DNS.Opcode != 0 ||
		dm.DNS.Rcode != RcodeToString(0) ||
		dm.DNS.Flags.QR ||
		dm.DNS.Flags.TC ||
		dm.DNS.Flags.AA ||
		!dm.DNS.Flags.AD ||
		dm.DNS.Flags.RA {
		t.Error("Invalid DNS header data in message")
	}

	if dm.DNS.Qname != "sensorfleet.com" {
		t.Errorf("Unexpected query name: %s", dm.DNS.Qname)
	}
	if dm.DNS.Qtype != "A" {
		t.Errorf("Unexpected query type: %s", dm.DNS.Qtype)
	}

	if dm.EDNS.Do != 1 ||
		dm.EDNS.UDPSize != 4096 ||
		dm.EDNS.Z != 0 ||
		dm.EDNS.Version != 0 ||
		len(dm.EDNS.Options) != 0 {
		t.Errorf("Unexpected EDNS data")
	}

	if len(dm.DNS.DNSRRs.Answers) != 0 ||
		len(dm.DNS.DNSRRs.Nameservers) != 0 ||
		len(dm.DNS.DNSRRs.Records) != 0 {
		t.Errorf("Unexpected sections parsed")
	}

}
func TestDecodePayload_QueryInvalid(t *testing.T) {
	payload := []byte{
		// header
		0x9e, 0x84, 0x01, 0x20, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01,
		// query section
		// name
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x83, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Additional records: EDNS OPT with no data, DO = 1, Z=0
		0x00, 0x00, 0x29, 0x10, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err == nil {
		t.Errorf("Expected error when parsing payload")
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be marked as malformed")
	}

	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeDNSLabelInvalidData) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodePayload_AnswerHappy(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, EDNS Option, 0 bytes DO=0, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Errorf("Unexpected error while decoding payload: %v", err)
	}
	if dm.DNS.MalformedPacket != false {
		t.Errorf("did not expect packet to be malformed")
	}

	if dm.DNS.ID != 0x9e84 ||
		dm.DNS.Opcode != 0 ||
		dm.DNS.Rcode != RcodeToString(0) ||
		!dm.DNS.Flags.QR ||
		dm.DNS.Flags.TC ||
		dm.DNS.Flags.AA ||
		dm.DNS.Flags.AD ||
		!dm.DNS.Flags.RA {
		t.Error("Invalid DNS header data in message")
	}

	if dm.DNS.Qname != "sensorfleet.com" {
		t.Errorf("Unexpected query name: %s", dm.DNS.Qname)
	}
	if dm.DNS.Qtype != "A" {
		t.Errorf("Unexpected query type: %s", dm.DNS.Qtype)
	}

	if len(dm.DNS.DNSRRs.Answers) != 4 {
		t.Errorf("expected 4 answers, got %d", len(dm.DNS.DNSRRs.Answers))
	}

	for i, ans := range dm.DNS.DNSRRs.Answers {
		expected := DNSAnswer{
			Name:      dm.DNS.Qname,
			Rdatatype: RdatatypeToString(0x0001),
			Class:     "IN", // 0x0001,
			TTL:       300,
			Rdata:     fmt.Sprintf("10.10.1.%d", i+1),
		}
		if expected != ans {
			t.Errorf("unexpected answer (%d). expected %v, got %v", i, expected, ans)
		}
	}

	if dm.EDNS.Do != 0 ||
		dm.EDNS.UDPSize != 1232 ||
		dm.EDNS.Z != 0 ||
		dm.EDNS.Version != 0 ||
		len(dm.EDNS.Options) != 0 {
		t.Errorf("Unexpected EDNS data")
	}

	if len(dm.DNS.DNSRRs.Nameservers) != 0 ||
		len(dm.DNS.DNSRRs.Records) != 0 {
		t.Errorf("Unexpected sections parsed")
	}

}

func TestDecodePayload_AnswerMultipleQueries(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x02, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		// query 1
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// query 2
		0x0a, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,

		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, EDNS Option, 0 bytes DO=0, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Errorf("Unexpected error while decoding payload: %v", err)
	}
	if dm.DNS.MalformedPacket != false {
		t.Errorf("did not expect packet to be malformed")
	}

	if dm.DNS.ID != 0x9e84 ||
		dm.DNS.Opcode != 0 ||
		dm.DNS.Rcode != RcodeToString(0) ||
		!dm.DNS.Flags.QR ||
		dm.DNS.Flags.TC ||
		dm.DNS.Flags.AA ||
		dm.DNS.Flags.AD ||
		!dm.DNS.Flags.RA {
		t.Error("Invalid DNS header data in message")
	}

	if dm.DNS.Qname != "ensorfleet.com" {
		t.Errorf("Unexpected query name: %s", dm.DNS.Qname)
	}
	if dm.DNS.Qtype != "A" {
		t.Errorf("Unexpected query type: %s", dm.DNS.Qtype)
	}

	if len(dm.DNS.DNSRRs.Answers) != 4 {
		t.Errorf("expected 4 answers, got %d", len(dm.DNS.DNSRRs.Answers))
	}

	for i, ans := range dm.DNS.DNSRRs.Answers {
		expected := DNSAnswer{
			Name:      "s" + dm.DNS.Qname, // answers have qname from 1st query data, 2nd data is missing 's'
			Rdatatype: RdatatypeToString(0x0001),
			Class:     "IN", // 0x0001,
			TTL:       300,
			Rdata:     fmt.Sprintf("10.10.1.%d", i+1),
		}
		if expected != ans {
			t.Errorf("unexpected answer (%d). expected %v, got %v", i, expected, ans)
		}
	}

	if dm.EDNS.Do != 0 ||
		dm.EDNS.UDPSize != 1232 ||
		dm.EDNS.Z != 0 ||
		dm.EDNS.Version != 0 ||
		len(dm.EDNS.Options) != 0 {
		t.Errorf("Unexpected EDNS data")
	}

	if len(dm.DNS.DNSRRs.Nameservers) != 0 ||
		len(dm.DNS.DNSRRs.Records) != 0 {
		t.Errorf("Unexpected sections parsed")
	}

}

func TestDecodePayload_AnswerInvalid(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0xff,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, EDNS Option, 0 bytes DO=0, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err == nil {
		t.Error("expected decoding to fail")
	}
	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeDNSLabelInvalidPointer) {
		t.Errorf("bad error returned: %v", err)
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}
}

func TestDecodePayload_AnswerInvalidQuery(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x83, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, EDNS Option, 0 bytes DO=0, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err == nil {
		t.Error("expected decoding to fail")
	}
	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeDNSLabelInvalidData) {
		t.Errorf("bad error returned: %v", err)
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}

	// after error has been detected in the query part, we should not parse
	// anything from answers
	if len(dm.DNS.DNSRRs.Answers) != 0 {
		t.Errorf("did not expect answers to be parsed, but there were %d parsed", len(dm.DNS.DNSRRs.Answers))
	}
}

func TestDecodePayload_AnswerInvalidEdns(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, Invalid EDNS Option
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x01,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err == nil {
		t.Error("expected decoding to fail")
	}
	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeEdnsOptionTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}
}

func TestDecodePayload_AnswerInvaliAdditional(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, Invalid RDLENGTH
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err == nil {
		t.Error("expected decoding to fail")
	}
	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeDNSAnswerRdataTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}
}

func TestDecodePayload_AnswerError(t *testing.T) {
	payload := []byte{
		// header
		0xa8, 0x1a, 0x81, 0x83, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x01, 0x00, 0x01,
		// query
		0x03, 0x66, 0x6f, 0x6f,
		0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x03,
		0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Authority section
		// name
		0xc0, 0x10,
		// type SOA, class IN
		0x00, 0x06, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x00, 0x3c,
		// RDLENGTH
		0x00, 0x26,
		// RDATA
		// MNAME
		0x03, 0x6e, 0x73, 0x31,
		0xc0, 0x10,
		// RNAME
		0x09, 0x64, 0x6e, 0x73, 0x2d, 0x61,
		0x64, 0x6d, 0x69, 0x6e, 0xc0, 0x10,
		// serial
		0x19, 0xa1, 0x4a, 0xb4,
		// refresh
		0x00, 0x00, 0x03, 0x84,
		// retry
		0x00, 0x00, 0x03, 0x84,
		// expire
		0x00, 0x00, 0x07, 0x08,
		// minimum
		0x00, 0x00, 0x00, 0x3c,
		// Additianl records, EDNS Option, 0 bytes DO=1, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00,
		0x00, 0x80, 0x00, 0x00, 0x00,
	}
	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Errorf("Unexpected error while decoding payload: %v", err)
	}
	if dm.DNS.MalformedPacket != false {
		t.Errorf("did not expect packet to be malformed")
	}

	if dm.DNS.ID != 0xa81a ||
		dm.DNS.Opcode != 0 ||
		dm.DNS.Rcode != RcodeToString(3) ||
		!dm.DNS.Flags.QR ||
		dm.DNS.Flags.TC ||
		dm.DNS.Flags.AA ||
		dm.DNS.Flags.AD ||
		!dm.DNS.Flags.RA {
		t.Error("Invalid DNS header data in message")
	}

	if dm.DNS.Qname != "foo.google.com" {
		t.Errorf("Unexpected query name: %s", dm.DNS.Qname)
	}
	if dm.DNS.Qtype != "A" {
		t.Errorf("Unexpected query type: %s", dm.DNS.Qtype)
	}

	if len(dm.DNS.DNSRRs.Answers) != 0 {
		t.Errorf("did not expect any answers, got %d", len(dm.DNS.DNSRRs.Answers))
	}

	if len(dm.DNS.DNSRRs.Nameservers) != 1 {
		t.Errorf("expected 1 authority RR, got %d", len(dm.DNS.DNSRRs.Nameservers))
	}
	expected := DNSAnswer{
		Name:      "google.com",
		Rdatatype: RdatatypeToString(0x0006),
		Class:     "IN", // 0x0001,
		TTL:       60,
		Rdata:     "ns1.google.com dns-admin.google.com 430000820 900 900 1800 60",
	}

	if dm.DNS.DNSRRs.Nameservers[0] != expected {
		t.Errorf("unexpected SOA record parsed, expected %v, git %v", expected, dm.DNS.DNSRRs.Nameservers[0])
	}

	if dm.EDNS.Do != 1 ||
		dm.EDNS.UDPSize != 1232 ||
		dm.EDNS.Z != 0 ||
		dm.EDNS.Version != 0 ||
		len(dm.EDNS.Options) != 0 {
		t.Errorf("Unexpected EDNS data")
	}

}

func TestDecodePayload_AnswerError_Invalid(t *testing.T) {
	payload := []byte{
		// header
		0xa8, 0x1a, 0x81, 0x83, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x01, 0x00, 0x01,
		// query
		0x03, 0x66, 0x6f, 0x6f,
		0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x03,
		0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Authority section
		// name
		0xc0, 0x10,
		// type SOA, class IN
		0x00, 0x06, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x00, 0x3c,
		// RDLENGTH
		0x00, 0x26,
		// RDATA
		// MNAME, invalid offset in pointer
		0x03, 0x6e, 0x73, 0x31,
		0xc0, 0xff,
		// RNAME
		0x09, 0x64, 0x6e, 0x73, 0x2d, 0x61,
		0x64, 0x6d, 0x69, 0x6e, 0xc0, 0x10,
		// serial
		0x19, 0xa1, 0x4a, 0xb4,
		// refresh
		0x00, 0x00, 0x03, 0x84,
		// retry
		0x00, 0x00, 0x03, 0x84,
		// expire
		0x00, 0x00, 0x07, 0x08,
		// minimum
		0x00, 0x00, 0x00, 0x3c,
		// Additianl records, EDNS Option, 0 bytes DO=1, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00,
		0x00, 0x80, 0x00, 0x00, 0x00,
	}
	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err == nil {
		t.Error("expected decoding to fail")
	}
	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeDNSLabelInvalidPointer) {
		t.Errorf("bad error returned: %v", err)
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}

}

func TestDecodePayload_AdditionalRRAndEDNS(t *testing.T) {
	// payload containing both addition RR and EDNS, ensure we are
	// able to parse all of them
	payload := []byte{
		0x7b, 0x97, 0x84, 0x0, 0x0, 0x1, 0x0, 0x2,
		0x0, 0x2, 0x0, 0x5, 0xf, 0x6f, 0x63, 0x63,
		0x2d, 0x30, 0x2d, 0x31, 0x35, 0x30, 0x30,
		0x2d, 0x31, 0x35, 0x30, 0x31, 0x1, 0x31,
		0x6, 0x6e, 0x66, 0x6c, 0x78, 0x73, 0x6f,
		0x3, 0x6e, 0x65, 0x74, 0x0, 0x0, 0x1, 0x0,
		0x1, 0xc0, 0xc, 0x0, 0x1, 0x0, 0x1, 0x0,
		0x0, 0x0, 0x1e, 0x0, 0x4, 0x2d, 0x39, 0x24,
		0x97, 0xc0, 0xc, 0x0, 0x1, 0x0, 0x1, 0x0,
		0x0, 0x0, 0x1e, 0x0, 0x4, 0x2d, 0x39, 0x24,
		0x94, 0xc0, 0x1e, 0x0, 0x2, 0x0, 0x1, 0x0,
		0x1, 0x51, 0x80, 0x0, 0x7, 0x1, 0x65, 0x2,
		0x6e, 0x73, 0xc0, 0x1e, 0xc0, 0x1e, 0x0,
		0x2, 0x0, 0x1, 0x0, 0x1, 0x51, 0x80, 0x0,
		0x4, 0x1, 0x66, 0xc0, 0x5c, 0x0, 0x0, 0x29,
		0x4, 0xb0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc0,
		0x5a, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x51, 0x80,
		0x0, 0x4, 0x2d, 0x39, 0x8, 0x1, 0xc0, 0x5a,
		0x0, 0x1c, 0x0, 0x1, 0x0, 0x1, 0x51, 0x80, 0x0,
		0x10, 0x2a, 0x0, 0x86, 0xc0, 0x20, 0x8, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xc0, 0x6d,
		0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x51, 0x80, 0x0, 0x4,
		0x2d, 0x39, 0x9, 0x1, 0xc0, 0x6d, 0x0, 0x1c, 0x0, 0x1,
		0x0, 0x1, 0x51, 0x80, 0x0, 0x10, 0x2a, 0x0, 0x86, 0xc0,
		0x20, 0x9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("error when deocoding header: %v", err)
	}

	if err := DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Errorf("unexpected error while decoding payload: %v", err)
	}

	if len(dm.DNS.DNSRRs.Answers) != 2 || len(dm.DNS.DNSRRs.Nameservers) != 2 ||
		len(dm.DNS.DNSRRs.Records) != 4 || dm.EDNS.UDPSize != 1200 ||
		len(dm.EDNS.Options) != 0 {
		t.Errorf("unexpected result while parsing payload: %#v", dm.DNS)
	}

}

func TestDecodePayload_Truncated(t *testing.T) {
	payload := []byte{
		// header
		0x77, 0xa0, 0x83, 0x80, 0x00, 0x01, 0x00, 0x23,
		0x00, 0x00, 0x00, 0x00,
		// query
		0x02, 0x41, 0x64, 0x0d,
		0x6e, 0x6e, 0x6e, 0x6e,
		0x6e, 0x6e, 0x6e, 0x6e,
		0x6e, 0x6e, 0x6e, 0x6e,
		0x6e, 0x02, 0x46, 0x52,
		0x00, 0x00, 0x01, 0x00, 0x01,
		// answer 1
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x01,
		// answer 2
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x02,
		// answer 3
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x03,
		// answer 4
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x04,
		// answer 5
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x05,
		// answer 6
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x06,
		// answer 7
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x07,
		// answer 8
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x08,
		// answer 9
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x09,
		// answer 10
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0a,
		// answer 11
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0b,
		// answer 12
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0c,
		// answer 13
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0d,
		// answer 14
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0e,
		// answer 15
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0f,
		// answer 16
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x10,
		// answer 17
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x11,
		// answer 18
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x12,
		// answer 19
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x13,
		// answer 20
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x14,
		// answer 21
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x15,
		// answer 22
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x16,
		// answer 23
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x17,
		// answer 24
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x18,
		// answer 25
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x19,
		// answer 26
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x1a,
		// answer 27
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x1b,
		// answer 28
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x1c,
		// answer 29
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x1d,
		// answer 30
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Error("expected no error on decode")
	}

	if dm.DNS.Flags.TC == false {
		t.Error("truncated answer expected")
	}

	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}

}

// Dynamic query (UPDATE)
func TestDecodePayload_UpdateQuery(t *testing.T) {
	payload := []byte{
		// transaction id
		0x75, 0xa1,
		// Update Query
		0x28, 0x00,
		// 1 zone, O prerequisites, 1 update, 0 additionnal
		0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
		// zone section
		// --> zone name
		0x00,
		// --> zone type SOA
		0x00, 0x06,
		// --> zone class
		0x00, 0x01,
		// update content
		// --> name
		0x14, 0x32, 0x31, 0x30, 0x32, 0x33, 0x31, 0x32, 0x52, 0x4d, 0x53, 0x31, 0x30, 0x4c, 0x32,
		0x30, 0x30, 0x30, 0x34, 0x35, 0x32, 0x00,
		// --> type: A
		0x00, 0x01,
		// --> class ANY
		0x00, 0xff,
		// --> ttl
		0x00, 0x00, 0x00, 0x00,
		// --> data length
		0x00, 0x00,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Error("expected no error on decode", err)
	}
}

func TestDecodePayload_MDNSResponseWithNoQuestion(t *testing.T) {
	payload := []byte{
		0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x0b, 0x5f, 0x67, 0x6f,
		0x6f, 0x67, 0x6c, 0x65, 0x63, 0x61, 0x73, 0x74, 0x04, 0x5f, 0x74, 0x63, 0x70, 0x05, 0x6c, 0x6f,
		0x63, 0x61, 0x6c, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x35, 0x32, 0x53,
		0x48, 0x49, 0x45, 0x4c, 0x44, 0x2d, 0x41, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2d, 0x54, 0x56,
		0x2d, 0x30, 0x66, 0x33, 0x31, 0x30, 0x63, 0x32, 0x63, 0x39, 0x66, 0x62, 0x62, 0x64, 0x61, 0x64,
		0x64, 0x31, 0x39, 0x39, 0x30, 0x30, 0x38, 0x31, 0x61, 0x61, 0x66, 0x35, 0x37, 0x65, 0x66, 0x38,
		0x33, 0xc0, 0x0c, 0xc0, 0x2e, 0x00, 0x10, 0x80, 0x01, 0x00, 0x00, 0x11, 0x94, 0x00, 0xd2, 0x23,
		0x69, 0x64, 0x3d, 0x30, 0x66, 0x33, 0x31, 0x30, 0x63, 0x32, 0x63, 0x39, 0x66, 0x62, 0x62, 0x64,
		0x61, 0x64, 0x64, 0x31, 0x39, 0x39, 0x30, 0x30, 0x38, 0x31, 0x61, 0x61, 0x66, 0x35, 0x37, 0x65,
		0x66, 0x38, 0x33, 0x23, 0x63, 0x64, 0x3d, 0x42, 0x35, 0x35, 0x36, 0x39, 0x31, 0x37, 0x42, 0x30,
		0x36, 0x33, 0x38, 0x46, 0x46, 0x32, 0x43, 0x35, 0x30, 0x45, 0x42, 0x43, 0x33, 0x34, 0x34, 0x41,
		0x45, 0x35, 0x31, 0x46, 0x39, 0x43, 0x37, 0x03, 0x72, 0x6d, 0x3d, 0x05, 0x76, 0x65, 0x3d, 0x30,
		0x35, 0x14, 0x6d, 0x64, 0x3d, 0x53, 0x48, 0x49, 0x45, 0x4c, 0x44, 0x20, 0x41, 0x6e, 0x64, 0x72,
		0x6f, 0x69, 0x64, 0x20, 0x54, 0x56, 0x12, 0x69, 0x63, 0x3d, 0x2f, 0x73, 0x65, 0x74, 0x75, 0x70,
		0x2f, 0x69, 0x63, 0x6f, 0x6e, 0x2e, 0x70, 0x6e, 0x67, 0x09, 0x66, 0x6e, 0x3d, 0x53, 0x48, 0x49,
		0x45, 0x4c, 0x44, 0x09, 0x63, 0x61, 0x3d, 0x34, 0x36, 0x33, 0x33, 0x36, 0x35, 0x04, 0x73, 0x74,
		0x3d, 0x31, 0x0f, 0x62, 0x73, 0x3d, 0x46, 0x41, 0x38, 0x46, 0x46, 0x36, 0x46, 0x30, 0x45, 0x30,
		0x38, 0x38, 0x04, 0x6e, 0x66, 0x3d, 0x31, 0x09, 0x63, 0x74, 0x3d, 0x30, 0x39, 0x31, 0x43, 0x44,
		0x34, 0x13, 0x72, 0x72, 0x3d, 0x41, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x4e, 0x61, 0x74, 0x69,
		0x76, 0x65, 0x41, 0x70, 0x70, 0x0b, 0x72, 0x73, 0x3d, 0x4a, 0x65, 0x6c, 0x6c, 0x79, 0x66, 0x69,
		0x6e, 0xc0, 0x2e, 0x00, 0x21, 0x80, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x2d, 0x00, 0x00, 0x00,
		0x00, 0x1f, 0x49, 0x24, 0x30, 0x66, 0x33, 0x31, 0x30, 0x63, 0x32, 0x63, 0x2d, 0x39, 0x66, 0x62,
		0x62, 0x2d, 0x64, 0x61, 0x64, 0x64, 0x2d, 0x31, 0x39, 0x39, 0x30, 0x2d, 0x30, 0x38, 0x31, 0x61,
		0x61, 0x66, 0x35, 0x37, 0x65, 0x66, 0x38, 0x33, 0xc0, 0x1d, 0xc1, 0x53, 0x00, 0x1c, 0x80, 0x01,
		0x00, 0x00, 0x00, 0x78, 0x00, 0x10, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x3e,
		0x51, 0x15, 0x8e, 0x6d, 0xa2, 0x96,
	}

	dm := DNSMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDNS(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, pkgconfig.GetDefaultConfig()); err != nil {
		t.Error("expected no error on decode", err)
	}
}
